1. Выявить все задачи, требуемые от регекса в проекте. Составить список этих задач. - выполнено
2. для каждой их задач найти решение. - выполнено
3. опробовать решения задач на прототипе и тестовых данных. - выполнено
4. написать код класса RegexManager для решения этих задач регекса. 
  - почти все выполнено, осталась функция public static String[] RegexManager.ParseCommandLine(String cmdline)
     для нее надо изучить способы запуска приложений на Линукс: надо ли вообще разделять командную строку на части и какие это части.
5. Создать набор данных и код для тестирования функций регекса на пригодных для проекта данных.
- чтобы быстро прогнать тесты  при изменениях в коде и убедиться, что ничего не сломалось.     

Задачи регекса в проекте:
1. Из регекса каждой Процедуры сделать нормальный регекс.
 - Это функция Engine.MakeNormalRegex()
 2. Функция RegexManager.ExtractArgumentsFromCommand() выполняет поиск и возвращает:
  - null если нет совпадений - процедура не годится для исполнения.
  - пустую коллекцию аргументов, если регекс Процедуры не содержит аргументов.
  - не пустую коллекцию аргументов, если регекс содержит аргументы.
  Далее список аргументов передается в Процедуру, которая решает, подходит ли ей этот набор аргументов.
 3. надо определить, путь исполнения это путь к процедуре или к  приложению.
 - Это функция RegexManager.IsAssemblyCodePath().
 - Подзадача: Решить, можно ли для проекта создавать и подключать во время исполнения сторонние сборки Процедур.
   Если нельзя, то все Процедуры придется реализовывать в коде Оператор.
   - И как тогда ссылаться на них из БД? Все равно надо как-то указывать, что данная Процедура размещена в сборке, хотя бы и в текущей сборке.
    