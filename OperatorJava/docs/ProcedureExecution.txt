================================
Документация проект OperatorJava
(C) 2022 Павел Селяков.
================================


++Путь к запускаемому методу Процедуры:
- названиеСборки.названиеКласса.НазваниеМетода

++Прототип запускаемого метода Процедуры:

EnumProcedureResult НазваниеМетода(Engine engine, String command, ArgumentCollection args);

Задачи прототипа:
1. Написать код доступа к методу класса в качестве Процедуры.
 + done
2. Из исходников Оператор извлечь структуру и использование атрибутов для пометки сборок, классов и методов, пригодных в качестве Процедур.
 + done.
3. придумать как реализовать этот механизм атрибутов на Java аннотациями.
 + done
4. Решить, нужен ли этот механизм, будем ли его использовать в Java версии Оператор.
 + done
5. Реализовать вызов процедуры в тестовом прототипе.
 + done
6. Реализовать вызов процедуры с использованием механизма аннотаций для предотвращения ошибок при использовании сборок.
7  Отработать код этой подсистемы более гладко и правильно. 
8. Составить инструкцию по реализации механизма вызова Процедур и создания сборок Процедур.
   Написать заготовки, описать процесс подключения к проекту и компиляции сборки процедур.
9. Описать устройство механизма выбора Процедур для пользователей, которые будут создавать собственные сборки процедур для Оператор.
10. Придумать, как забирать списки объектов Команд из СборкиПроцедур при старте Оператор, а не хранить их в БД.
  Так как если Пользователь написал свою сборку Процедур, то вот с наполнением ими БД у него может возникнуть путаница.
  А при автозагрузке данных о процедурах из самой сборки Процедур - проблем не будет. 
  А в БД тогда будут храниться только данные Процедур, созданных пользователем из самого Оператор.
  - там надо тогда некий класс-заголовок сборки сделать, и из него все это получать,
     и данные о версии сборки процедур - тоже хорошо бы оттуда же получать. 
     - это рассматривалось для Оператор-2, но зависло пока что.
11. Добавить в проект библиотеку функций для кода Процедур.
    Сейчас все Процедуры либо используют функции из Движка, либо реализуют их в своей сборке.
    Надо вынести эти функции в отдельную сборку - библиотеку функций для сборок Процедур Оператор.
 + done: ProcedureUtils library   
12. Когда все это будет сделано - придется переписывать оператор на шарпе на эту новую конфигурацию!
    Тут очень много нововведений получается.        
=====================================================
Образец - шаблон сборки процедур:
     
﻿using System;
using System.Collections.Generic;
using System.Text;
using Operator;        	- эта сборка ссылается на сборку Оператор
using Operator.Lexicon;


namespace FirstProcedures
{
    /// <summary>
    /// Класс должен содержать реализации процедур для команд Оператора
    /// </summary>
    public static class Procedures 
    {
        ///// <summary>
        ///// Пример функции процедуры обработчика команды
        ///// </summary>
        ///// <param name="engine">Механизм исполнения команд</param>
        ///// <param name="query">Текст запроса для возможной дополнительной обработки</param>
        ///// <param name="args">Список аргументов</param>
        ///// <returns>
        ///// Вернуть ProcedureResult.Success в случае успешного выполнения команды.
        ///// Вернуть ProcedureResult.WrongArguments если аргументы не подходят для запуска команды.
        ///// Вернуть ProcedureResult.Error если произошла ошибка при выполнении операции
        ///// Вернуть ProcedureResult.ExitXXX если нужно завершить работу текущего приложения, выключить или перезагрузить компьютер.
        ///// </returns>
        //[ProcedureAttribute(ImplementationState.NotTested)]//изменить состояние ImplementationState на подходящее после отладки функции
        //public static ProcedureResult CommandHandlerExample(Engine engine, string query, ArgumentCollection args)
        //{
        //    //вернуть флаг продолжения работы
        //    return ProcedureResult.Success;
        //}

        /// <summary>
        /// Пример функции процедуры обработчика команды
        /// </summary>
        /// <param name="engine">Механизм исполнения команд</param>
        /// <param name="query">Текст запроса для возможной дополнительной обработки</param>
        /// <param name="args">Список аргументов</param>
        /// <returns></returns>
        [ProcedureAttribute(ImplementationState.NotTested)]
        public static ProcedureResult CommandHandlerExample(Engine engine, string query, ArgumentCollection args)
        {
            //вывести сообщение на консоль Оператора
            engine.OperatorConsole.PrintTextLine("Message from command handler function", DialogConsoleColors.Сообщение);
            //вернуть флаг продолжения работы
            return ProcedureResult.Success;
        }

    }
}



==============================================================================

Набросок исполнения Процедур из сборок Процедур:

Сборки - библиотеки Процедур представлены jar-файлами с расширением .jar, которые хранят все скомпилированные классы этой библиотеки.
Но библиотека не загружается в память вся - вместо этого в память загружается только требуемый класс, который извлекается из архива, 
и затем извлекаются и загружаются связанные с ним классы. Так что это все очень медленно работает.
Зато классы потом выгружаются сборщиком мусора как обычные объекты, вроде бы.
Библиотеки не допускают добавления в них Процедур или Мест через Оператор.
Библиотеки должны иметь версию библиотеки, чтобы различать их версии.
Но поскольку названия библиотек должны быть уникальными, одноименные библиотеки не могут существовать в системе. 
  И версия библиотеки при этом не имеет значения.

Вызов процедуры из сборки процедур:
- класс PEM отвечает за управление библиотеками Процедур.
  - он ищет все библиотеки, которые есть в папке библиотек Оператора.

  - он загружает библиотеку - вернее, загружает и инициализирует статический менеджер библиотеки LibraryManager.
  - он извлекает из библиотеки Процедуры и Места для работы Оператора. Для этого вызываются функции LibraryManager.
  - он получает версию библиотеки - Для этого вызываются функции LibraryManager.
    - TODO: надо определить, как проверять, что версия данной библиотеки совместима с текущей версией Оператора.
  - он выгружает библиотеку - вернее, вызывает функцию деинициализации ресурсов библиотеки. Для этого вызываются функции LibraryManager.
- класс LibraryManager производный от LibraryManagerBase выполняет управление своей библиотекой. Он должен размещаться внутри пакета библиотеки, 
  иначе JAVA-машина не сможет его загрузить, так как разницы с другими классами с тем же названием не обнаружит. 


Библиотека Процедур состоит из:
- GeneralProcedures			- Проект библиотеки: Название библиотеки и jar-файла
 - GeneralProcedures		- Пакет: с тем же названием, что и библиотека
   - LibraryManager.java	- Класс менеджера библиотеки с фиксированным стандартным названием. 
   								Класс должен быть помечен аннотацией OperatorProcedure.
   								Класс должен быть производным от ProcedureSubsystem.LibraryManagerBase.
   - package-info.java  	- Файл описания пакета: пакет должен быть помечен аннотацией OperatorProcedure
   - TestProcedures.java	- Файл класса с статическими методами Процедур: класс должен быть помечен аннотацией OperatorProcedure. 
                               Каждый метод Процедур должен иметь стандартный список аргументов и должен быть помечен аннотацией OperatorProcedure. 
 - Utility					- Пакет вспомогательного кода: название произвольное, помечать аннотацией не требуется.
   - SomeClass.java  		- Файл класса вспомогательного кода:  название произвольное, помечать аннотацией не требуется.
   
    
Работа механизма исполнения Процедур:
1. инициализация PEM происходит при старте Оператора. 
1.1 Создать словарь библиотек
  PEM получает каталог библиотек Оператора и извлекает из него пути всех jar-файлов библиотек.
  Эти файлы и их названия без расширения помещаются в словарь PEM <Имя, Путь>.
1.2 Инициализировать все библиотеки, Получить все Процедуры и Места из библиотек.


2. Исполнение процедуры из библиотеки.
-  нужная библиотека выбирается по названию сборки из пути к Процедуре.
  По этому ключу в словаре получаем путь к файлу, затем загружаем требуемый класс, получаем из него требуемый метод и запускаем его.
  По пути проверяем наличие и состояние аннотации OperatorProcedure. 
  Если аннотация в состоянии для Отладки - выводим сообщение об этом на консоль, но продолжаем исполнение.
  Если аннотация в состоянии не готово - выбрасываем исключение с сообщением об этом.
  Это исключение должно быть перехвачено и отображено на экране и записано в лог Оператора.
  Как ошибка в процессе исполнения Процедуры.

3. Завершение работы PEM
Происходит в процесе завершения работы Оператора.
- важно помнить, что процесс Оператора может внезапно прерваться, поэтому данные библиотек должны быть некритичными к таким событиям.
3.1 вызвать очистку данных для каждой библиотеки из соваря библиотек.

Замечания:
- LibraryManager это класс, который должен управлять всей библиотекой Процедур.
- этот механизм сейчас предполагает модуль как в Виндовс: DLL вся загружается в память и там висит все время.
  И внутри нее все эти данные, итп, хранятся.
  А тут в Яве классы загружаются самостоятельными единицами. Поэтому тут нужен другой способ.
- сейчас предполагается, что каждая Процедура сама по себе, и никакие общие данные не использует.
  Если же предполагаются некие общие данные, то нужно их хранить, получать ссылку на них, инициализировать, завершать работу, итп.  
- реализация библиотеки Процедур как плагина?  
  - Класс LibraryManager должен создавать объект, который бужет храниться в словаре в PEM, а Процедуры должны вызываться из/для этого объекта.
  - Объект класса LibraryManager должен храниться в памяти, и через него должны вызываться методы классов.
  - Каждая Процедура должна соответственно получать ссылку на Объект класса LibraryManager как на ссылку для доступа к ранее инициализированным ресурсам.
    Сами же ресурсы хранятся в этом объекте.
    - ссылку на Движок Процедура может получать из объекта класса LibraryManager, а не как аргумент вызова.
  - Это потребует переделывать все созданные к этому моменту Процедуры на новый формат Плагина.  
  - TODO: отложить реализацию фичи "Библиотеки Процедур как плагины" на более поздний релиз Оператора.  
    Сейчас же необходимости в этом нет.
    
===========================================
Идея: переделать все на новую систему хранения Процедур и Мест.
- Места и Процедуры сейчас хранятся только в БД.
  - Это неудобно для разработки Библиотек Процедур - надо вносить все новые Процедуры в БД и только потом тестировать и использовать.
- Предлагается хранить Процедуры и Места внутри Библиотек Процедур и загружать в кеш-коллекцию в памяти, откуда и брать для исполнения.
- Места и Процедуры нужно также добавлять, удалять и редактировать.
  - Это нужно для БД, а в Библиотеках Процедур редактирование или удаление пока неясно, потребуется ли.
    Но интерфейс для этого следует предусмотреть.
- А чем БД отличается от Библиотек Процедур? 
  - как и Библиотека Процедур, БД хранит Места, Процедуры.
  - она может хранить неймспейсы для Мест и Процедур Оператора.
    - неймспейсы можно точно так же, как Места и Процедуры, загружать из Библиотек Процедур в общую кеш-коллекцию. 
  - она может хранить различые настройки Оператора.        
    - и вроде бы это единственное отличие?
  - и значит, можно и БД считать Библиотекой Процедур и единообразно управлять этими библиотеками через единый интерфейс?
    - теоретически - да, но такая переделка - новая архитектура системы, а мне сейчас нужно наскоро создать первый работающий прототип.
      Поэтому сейчас отложим эту идею на будущее.
- Места и Процедуры как Элементы, должны теперь содержать ссылку на место, где они хранятся, чтобы знать, куда записывать изменения в них.
  Простой способ состоит в том, чтобы в каждый Элемент записать ссылку на источник-менеджер, который и будет выполнять действия по изменению элемента.
- Можно заодно уже добавить неймспейсы для Элементов. Для начала, для простоты в один ряд их организовать, без вложенности неймспейсов.
  Проблема здесь в том, что неймспейсы глобальные для системы, а в Библиотеках Процедур они должны указываться для каждого Элемента. 
  Получится, что неймспейс из одной Библиотеки Процедур должен использоваться в другой Библиотеке Процедур. Тут могут быть сложности.
- все это можно попробовать реализовать на Тапп, но для Виндовс только. Сейчас незачем.  
   
=== Обработка встроенных команд Оператор ===
В старом Оператор встроенные команды перехватывались до отправки их в механизм Процедур, и обрабатывались независимо от него.
И не попадали под правило Если латинские символы - перенаправить запрос в Терминал. 

В новом Оператор надо сделать так же.
- встроенные команды так же перехватываются до механизма Процедур.
- для каждой команды должно быть поле строки в файле настроек.
- если соответствующее поле в настройках пустое, то текст запроса перенаправляется в механизм Процедур.
  Где происходит поиск обычным образом.
- Значит, для встроенной команды либо командная строка должна быть указана в Файле Настроек Оператора, 
   либо реализована Процедура в БД, как запуск утилиты либо метод-из-кода.
- Поскольку для встроенных команд на разных ОС разные тексты, то Процедуры не должны быть зафиксированы в коде Библиотек Процедур.
  Следовательно, Процедуры для встроенных команд должны располагаться только в БД. 
  Чтобы их можно было изменить под текущую ОС.











       