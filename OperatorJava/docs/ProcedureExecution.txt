

++Путь к запускаемому методу Процедуры:
- названиеСборки.названиеКласса.НазваниеМетода

++Прототип запускаемого метода Процедуры:

EnumProcedureResult НазваниеМетода(Engine engine, String command, ArgumentCollection args);

Задачи прототипа:
1. Написать код доступа к методу класса в качестве Процедуры.
2. Из исходников Оператор извлечь структуру и использование атрибутов для пометки сборок, классов и методов, пригодных в качестве Процедур.
 - done.
3. придумать как реализовать этот механизм атрибутов на Java аннотациями.
4. Решить, нужен ли этот механизм, будем ли его использовать в Java версии Оператор.
5. Реализовать вызов процедуры в тестовом прототипе.
6. Реализовать вызов процедуры с использованием механизма аннотаций для предотвращения ошибок при использовании сборок.
7  Отработать код этой подсистемы более гладко и правильно. 
8. Составить инструкцию по реализации механизма вызова Процедур и создания сборок Процедур.
   Написать заготовки, описать процесс подключения к проекту и компиляции сборки процедур.
9. Описать устройство механизма выбора Процедур для пользователей, которые будут создавать собственные сборки процедур для Оператор.
10. Придумать, как забирать списки объектов Команд из СборкиПроцедур при старте Оператор, а не хранить их в БД.
  Так как если Пользователь написал свою сборку Процедур, то вот с наполнением ими БД у него может возникнуть путаница.
  А при автозагрузке данных о процедурах из самой сборки Процедур - проблем не будет. 
  А в БД тогда будут храниться только данные Процедур, созданных пользователем из самого Оператор.
  - там надо тогда некий класс-заголовок сборки сделать, и из него все это получать,
     и данные о версии сборки процедур - тоже хорошо бы оттуда же получать. 
     - это рассматривалось для Оператор-2, но зависло пока что.
11. Добавить в проект библиотеку функций для кода Процедур.
    Сейчас все Процедуры либо используют функции из Движка, либо реализуют их в своей сборке.
    Надо вынести эти функции в отдельную сборку - библиотеку функций для сборок Процедур Оператор.
12. Когда все это будет сделано - придется переписывать оператор на шарпе на эту новую конфигурацию!
    Тут очень много нововведений получается.        
=====================================================
Образец - шаблон сборки процедур:
     
﻿using System;
using System.Collections.Generic;
using System.Text;
using Operator;        	- эта сборка ссылается на сборку Оператор
using Operator.Lexicon;


namespace FirstProcedures
{
    /// <summary>
    /// Класс должен содержать реализации процедур для команд Оператора
    /// </summary>
    public static class Procedures 
    {
        ///// <summary>
        ///// Пример функции процедуры обработчика команды
        ///// </summary>
        ///// <param name="engine">Механизм исполнения команд</param>
        ///// <param name="query">Текст запроса для возможной дополнительной обработки</param>
        ///// <param name="args">Список аргументов</param>
        ///// <returns>
        ///// Вернуть ProcedureResult.Success в случае успешного выполнения команды.
        ///// Вернуть ProcedureResult.WrongArguments если аргументы не подходят для запуска команды.
        ///// Вернуть ProcedureResult.Error если произошла ошибка при выполнении операции
        ///// Вернуть ProcedureResult.ExitXXX если нужно завершить работу текущего приложения, выключить или перезагрузить компьютер.
        ///// </returns>
        //[ProcedureAttribute(ImplementationState.NotTested)]//изменить состояние ImplementationState на подходящее после отладки функции
        //public static ProcedureResult CommandHandlerExample(Engine engine, string query, ArgumentCollection args)
        //{
        //    //вернуть флаг продолжения работы
        //    return ProcedureResult.Success;
        //}

        /// <summary>
        /// Пример функции процедуры обработчика команды
        /// </summary>
        /// <param name="engine">Механизм исполнения команд</param>
        /// <param name="query">Текст запроса для возможной дополнительной обработки</param>
        /// <param name="args">Список аргументов</param>
        /// <returns></returns>
        [ProcedureAttribute(ImplementationState.NotTested)]
        public static ProcedureResult CommandHandlerExample(Engine engine, string query, ArgumentCollection args)
        {
            //вывести сообщение на консоль Оператора
            engine.OperatorConsole.PrintTextLine("Message from command handler function", DialogConsoleColors.Сообщение);
            //вернуть флаг продолжения работы
            return ProcedureResult.Success;
        }

    }
}

======================================================================

﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Operator
{
    /// <summary>
    /// Element type mark as code realization stage
    /// </summary>
    public enum ImplementationState
    {
        /// <summary>
        /// Method realization in progress
        /// </summary>
        NotRealized = 0,
        /// <summary>
        /// Method, class, assembly is realized, but not tested
        /// </summary>
        NotTested,
        /// <summary>
        /// Method, class, assembly is full tested and ready to use
        /// </summary>
        Ready,
    }

    /// <summary>
    /// Mark element (assembly, class, method) as a method implementation element with specify an implementation stage
    /// </summary>
    /// <remarks>This attribute marks assemblies, classes and functions as usable in method execution process.
    /// If assembly, class, function has this attribute, user can view and select as method realization.</remarks>
    public class ProcedureAttribute : Attribute
    {
        private ImplementationState elem;

        /// <summary>
        /// Params constructor
        /// </summary>
        /// <param name="ie">one of ImplementationElement values</param>
        public ProcedureAttribute(ImplementationState ie)
        {
            elem = ie;
        }
        /// <summary>
        /// Implementation element type
        /// </summary>
        public ImplementationState ElementValue
        {
            get { return elem; }
            set { elem = value; }
        }


    }
}

==============================================================================

Набросок исполнения Процедур из сборок Процедур:

Сборки - библиотеки Процедур представлены jar-файлами с расширением .jar, которые хранят все скомпилированные классы этой библиотеки.
Но библиотека не загружается в память вся - вместо этого в память загружается только требуемый класс, который извлекается из архива, 
и затем извлекаются и загружаются связанные с ним классы. Так что это все очень медленно работает.
Зато классы потом выгружаются сборщиком мусора как обычные объекты, вроде бы.
Библиотеки не допускают добавления в них Процедур или Мест через Оператор.
Библиотеки должны иметь версию библиотеки, чтобы различать их версии.
Но поскольку названия библиотек должны быть уникальными, одноименные библиотеки не могут существовать в системе. 
  И версия библиотеки при этом не имеет значения.

Вызов процедуры из сборки процедур:
- класс PEM отвечает за управление библиотеками Процедур.
  - он ищет все библиотеки, которые есть в папке библиотек Оператора.

  - он загружает библиотеку - вернее, загружает и инициализирует статический менеджер библиотеки LibraryManager.
  - он извлекает из библиотеки Процедуры и Места для работы Оператора. Для этого вызываются функции LibraryManager.
  - он получает версию библиотеки - Для этого вызываются функции LibraryManager.
    - TODO: надо определить, как проверять, что версия данной библиотеки совместима с текущей версией Оператора.
  - он выгружает библиотеку - вернее, вызывает функцию деинициализации ресурсов библиотеки. Для этого вызываются функции LibraryManager.
- класс LibraryManager производный от LibraryManagerBase выполняет управление своей библиотекой. Он должен размещаться внутри пакета библиотеки, 
  иначе JAVA-машина не сможет его загрузить, так как разницы с другими классами с тем же названием не обнаружит. 


Библиотека Процедур состоит из:
- GeneralProcedures			- Проект библиотеки: Название библиотеки и jar-файла
 - GeneralProcedures		- Пакет: с тем же названием, что и библиотека
   - LibraryManager.java	- Класс менеджера библиотеки с фиксированным стандартным названием. 
   								Класс должен быть помечен аннотацией OperatorProcedure.
   								Класс должен быть производным от ProcedureSubsystem.LibraryManagerBase.
   - package-info.java  	- Файл описания пакета: пакет должен быть помечен аннотацией OperatorProcedure
   - TestProcedures.java	- Файл класса с статическими методами Процедур: класс должен быть помечен аннотацией OperatorProcedure. 
                               Каждый метод Процедур должен иметь стандартный список аргументов и должен быть помечен аннотацией OperatorProcedure. 
 - Utility					- Пакет вспомогательного кода: название произвольное, помечать аннотацией не требуется.
   - SomeClass.java  		- Файл класса вспомогательного кода:  название произвольное, помечать аннотацией не требуется.
   
    
Работа механизма исполнения Процедур:
1. инициализация PEM происходит при старте Оператора. 
1.1 Создать словарь библиотек
  PEM получает каталог библиотек Оператора и извлекает из него пути всех jar-файлов библиотек.
  Эти файлы и их названия без расширения помещаются в словарь PEM <Имя, Путь>.
1.2 Инициализировать все библиотеки, Получить все Процедуры и Места из библиотек.


2. Исполнение процедуры из библиотеки.
-  нужная библиотека выбирается по названию сборки из пути к Процедуре.
  По этому ключу в словаре получаем путь к файлу, затем загружаем требуемый класс, получаем из него требуемый метод и запускаем его.
  По пути проверяем наличие и состояние аннотации OperatorProcedure. 
  Если аннотация в состоянии для Отладки - выводим сообщение об этом на консоль, но продолжаем исполнение.
  Если аннотация в состоянии не готово - выбрасываем исключение с сообщением об этом.
  Это исключение должно быть перехвачено и отображено на экране и записано в лог Оператора.
  Как ошибка в процессе исполнения Процедуры.

3. Завершение работы PEM
Происходит в процесе завершения работы Оператора.
- важно помнить, что процесс Оператора может внезапно прерваться, поэтому данные библиотек должны быть некритичными к таким событиям.
3.1 вызвать очистку данных для каждой библиотеки из соваря библиотек.

















       