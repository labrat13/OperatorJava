================================
Документация проект OperatorJava
(C) 2022 Павел Селяков.
================================


Процесс исполнения запроса Оператор
- TODO: добавить события здесь
- TODO: добавлять ли в лог сообщения о наступлении событий? Надо бы, как этапы процесса.
- TODO: некоторые действия для Процедуры следует выполнить однократно при загрузке Процедуры в Коллекцию,
  а не каждый раз при выполнении команды. Но это потребует внесения изменений в объект Procedure, 
   а это лишняя работа при переделке процесса исполнения запроса.
   Поэтому желательно сначала спроектировать процесс исполнения запроса, а потом внести изменения в объект процедуры.
- в конце процедуры инициализации нужно выполнить команду(команды), указанную(ые) в ФайлНастроекОператора с ключом startup.
- при нормальном завершении Оператора нужно выполнить команду(команды), указанную(ые) в ФайлНастроекОператора с ключом onexit.     
  - вызывать это в функции цикла обработки запросов, соответственно, до и после цикла обработки запросов.
- TODO: добавить в документацию, что в этой версии Оператор пользователь кроме естественно-язычного запроса, 
   может также вводить путь к Процедуре в обычном формате Библиотека.Класс.Функция().
   Процедуре не передаются аргументы, поэтому таким образом можно запустить только Процедуры без аргументов.
   Эта побочная возможность существует из-за функции пред-обработки для встроенных команд Оператора.
   Хотя ее можно закрыть в коде, конечно.
      

- Создание объекта Движка Engine
  - Engine()

- Инициализация движка:
  - Init()

	
- Запуск цикла обработки запросов:
  TODO: Предполагается, что обработка результата цикла производится в вызывающем коде приложения.
        А там много работы, и лучше бы ее оттуда убрать.
        Тогда, соответственно, нужно возвращаемые коды переделать.
        И весь этот цикл перепроектировать.
  - ProcessLoop()
    - ввод сообщения через OperatorConsole.ReadLine()
    - вывести сообщение о начале обработки запроса в лог
    - пред-обработка запроса:
      - TODO: вывести это в отдельную функцию, так как будут дополнения в процесс.
      - встроенные команды могут добавляться по мере развития проекта. 
      - если это команда спать, то выполняется функция перехода в спящий режим.
      - если это команда выход, то функция завершается с кодом Exit.
      - если это команда выключить, то функция завершается с кодом ExitAndShutdown.
      - если это команда перезагрузить, то функция завершается с кодом ExitAndReload.
      - если это команда завершить сеанс, то функция завершается с кодом ExitAndLogout.
       	- TODO: если команда требует действие, то надо выполнить это действие.
          Для этого надо превратить команду в текст запроса либо путь к Процедуре без аргументов, 
           и запустить исполнение запроса DoQuery() или исполнение указанной Процедуры 
	   (TODO: добавить сюда функцию, которая исполняет Процедуру по указанному пути).
         - Настройки Оператора и БД Оператора должны содержать поля для замены кода возврата либо кода встроенной команды на строку запроса либо путь к процедуре без аргументов.
           - сначала проверяется файл Настроек Оператора, затем БД Оператора.
           - если настройки для данного кода нет или поле пустое, то TODO: решить, что делать:
             - А) пропустить и перейти к новому циклу ожидания запроса.
               - Оператор будет работать неправильно и пользователь не обнаружит причину.
             - Б) вывести сообщение об отсутствии настройки для выполнения команды и пропустить (А).
	       - пользователь не обнаружит, что что-то пошло не так, в сложном сценарии работы.
             - В) вывести сообщение и запрос команды для исполнения.
               - приемлемый вариант
	     - Г) вывести сообщение и запрос команды для исполнения, предложить записать эту команду для последующего повторения.
               - более удобно, чем В).
             - Д) вывести сообщение об ошибке и остановить работу Оператор. 
	       - позволяет обнаружить повреждения в настройках на уже настроенной системе.
                 - TODO: надо проверять КС файла настроек при загрузке файла настроек, чтобы обнаруживать повреждения и выводить пользователю сообщение об этом.
	       - Высокий порог вхождения: редкий пользователь сможет запустить Оператор в первый раз - надо же прочитать инструкцию и выставить все эти настройки! 

      
    - вызывается событие EventCommandArrived(query); она возвращает результат выполнения запроса.
      - TODO: определиться, должны ли события нести функциональность, или только отмечать точки для модификации процесса?
      - TODO: определиться, должны ли события возвращать результат и иметь возможность модифицировать результат процесса?
      - вызывает Lexicon.BCSA.ProcessQuery(this, query)
        - тут должна происходить семантическая обработка запроса, но пока он просто передается дальше.
        - тут можно поставить событие EventQuerySemanticProcessing(), в котором переопределить запрос позже.
        - engine.DoQuery(query);
          - Если запрос не русскоязычный, то передать его в терминал.
            - TODO: это может конфликтовать с семантической обработкой запроса, надо было поставить эту проверку раньше семантического запроса, где-то сразу после пред-обработки.
              - добавить этот комментарий в код и пока ничего не менять. Возможно, в ходе семантической обработки запроса потребуется исполнение команд терминала.
          - перебором всех Процедур из коллекции пытаемся найти подходящую Процедуру и исполнить запрос.
            - TODO: добавить комментарий о желательности первичного отбора Процедур для уменьшения их количества, по первому слову регекса.
              - но перезапуск просмотра процедур будет cложнее реализовать тогда. Нужно будет заново проводить отбор Процедур.
                Так как текст запроса может быть изменен предыдущей Процедурой.
                - сейчас изменение текста запроса внутри Процедуры не реализовано и не поддерживается. 
                   Заголовки функций Процедур не позволяют вернуть модифицированый текст запроса.  
            - собрать нормальный регекс для данной Процедуры
              - TODO: сделать это однократно при загрузке Процедуры в коллекцию, а не каждый раз перед исполнением, как сейчас.
            - извлечь из запроса аргументы для вызова Процедуры
              - если массив аргументов не пустой, то вызвать исполнение  Процедуры: 
                result = Execute(query, regex, p, args);
                 - сопоставить Места аргументам, наскоько возможно.
                   TryAssignPlaces(ArgumentCollection args)
                   - для каждого аргумента из массива:
                     - перебрать все Места в коллекции Мест Оператора и получить Место по одному из его синонимов.
                        Ссылку на найденное место вписать в объект Аргумента. 
                        Если ничего не найдено, ничего не вписывать.
                       - TODO: если будет найдено более одного Места, надо запросить пользователя, какое Место выбрать.
                         - но ему надо показать и описание Места и его значение для исполняемой Процедуры.
                            Хорошо, если он это поймет из собственного контекста. А если нет - наобум выбирать.
                           И тогда это будет уже дополнительный диалог уточнения команды, а пользователь не любит уточнять.
                           - тут можно добавить событие для семантической обработки: уточнить, какое именно место использовать в данном случае.
                         - и хорошо бы однократно выбрать это Место для всех далее выбираемых Процедур.
                           - тогда надо перенести эту функцию присвоения Мест аргументам в начало цикла выборки Процедуры.
                         - а сейчас я положил, что один синоним = одно Место, и всех этих проблем избежал, но получилось не очень удобно для работы пользователя.       
                 - если путь Процедуры - путь к сборке Библиотеки Команд, то:
                   - TODO: можно было определить это однократно при загрузке Процедуры в коллекцию.
                    приготовить аргументы, найти сборку, вызвать функцию, передать ей аргументы и вернуть результат: 
                   		return RunLocalAssembly(command, p, args);
                   - разделить путь Процедуры на части
                     - TODO: можно было сделать это однократно при загрузке Процедуры в коллекцию.
                   - запустить исполнение Процедуры:
                      result = this.m_PEM.invokeProcedure(p, names, command, this, args);
                       // Это выбрасывает исключения процесса запуска и исполнения Процедуры.
                     - если возникло исключение, то
                       - вывести сообщение об исключении на консоль
                       - добавить сообщение об исключении в лог
                       - вернуть результат WrongArguments; 
                         - TODO: исключение это ошибка при исполнении Процедуры.
                           Ошибка может возникнуть из-за неверного значения аргумента или несоответствующего состояния системы.
                           А это значение продолжает поиск подходящей Процедуры в колекции.
                           Это явно неправильное значение, но тут надо перепроектировать весь процесс исполнения Процедуры, отделив ошибку исполнения Процедуры от несоответствия запроса, аргументов и смысла процедуры.
                           И я не знаю, что делать, если при исполнении Процедуры возникла ошибка.
                           Но не прекращать же цикл и работу Оператора из-за первой же ошибки, возможно, не принесшей повреждений данных!
                           А надо бы - прервать исполнение запроса, чтобы Пользователь мог разобраться, что произошло и восстановить состояние данных.
                           Тут надо лучше проработать процесс. 
                     - если же исключения не возникло, то вернуть результат Процедуры.
                     	
                 - иначе
                      Это путь к приложению, его надо запустить и вернуть стандартное значение для продолжения работы Оператор.
                      Поскольку приложение не может возвращать значения, кроме значения ошибки, да и те - не всегда.
                   		return RunShellExecute(p, args);
                   - вставить аргументы в командную строку приложения
                   - запустить приложение через ShellExecute
                     - TODO: я не знаю, как это делать в Линукс, да еще в разных ее версиях.
                     - Это выбрасывает исключения процесса запуска и исполнения приложения.
                     - если возникло исключение, то
                       - вывести сообщение об исключении на консоль
                       - добавить сообщение об исключении в лог
                       - вернуть результат WrongArguments; 
                         - TODO: исключение это ошибка при исполнении приложения.
                           Ошибка может возникнуть из-за неверного значения аргумента или несоответствующего состояния системы.
                           При этом приложение не было запущено, так как оно - отдельный Процесс и не передает свои исключения сюда.
                           А это значение продолжает поиск подходящей Процедуры в коллекции.
                           А надо бы - прервать исполнение запроса, чтобы Пользователь мог разобраться, что произошло и восстановить состояние данных.
                           Тут надо лучше проработать процесс. 
                     - если же исключения не возникло, то вернуть результат Процедуры.		
                
              - если процедура вернула значение  EnumProcedureResult.WrongArguments
                то перейти к следующей Процедуре из коллекции.   
            - если найти Процедуру не удалось, вызвать событие  EventCommandNotExecuted();
              и вернуть  EnumProcedureResult.Success
              - TODO: а почему вернуть Успех? Лучше значений не придумалось? Надо перепроектировать процесс исполнения запроса..
              - выводит на консоль сообщение Я такое не умею.
                - TODO: здесь добавить в лог сообщение об этом? 
                 
                  
    - на консоль выводится текстовое описание результата выполнения запроса.
    
    - выполняется пост-обработка запроса:
      - см. пред-обработка запроса - там полезная информация.
      - если код результата - завершить работу Оператор, то функция завершается с кодом результата.
	- TODO: если код результата Процедуры требует действие, то надо выполнить это действие.
          Для этого надо превратить код результата в текст запроса либо путь к Процедуре без аргументов, 
           и запустить исполнение запроса DoQuery() или исполнение указанной Процедуры 
	   (TODO: добавить сюда функцию, которая исполняет Процедуру по указанному пути).
    - конец цикла обработки запроса
      
      
  
- Завершение движка:
  - Exit() 
  